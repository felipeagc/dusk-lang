type Hello struct {
    a: int,
    b: float,
};

let(push_constant) pc : struct (std140) {
    a: float3,
};

[set(0), binding(0)]
let(uniform) uniform : struct (std140) {
    a: int,
    b: float,
    c: float3,
    some_arr: []float,
};

[set(0), binding(1), read_only]
let(storage) camera_buffers: []struct (std430) {
    cameras: []struct (std430) {
        pos: float4,
        view: float4x4,
        proj: float4x4,
    },
};

[set(0), binding(2)] let image : @Image2D(float);
[set(0), binding(3)] let image2 : @Image3DSampler(float);
[set(0), binding(4)] let sampler : @Sampler();

fn test(param: int) int {
    let a: int = param;
    return a;
}

fn test2(param: int) int {
    return param;
}

type VsOutput struct {
    [builtin(position)] pos: float3,
};

type VsInput struct {
    [location(0)] pos: float3,
    [location(1)] uv: float2,
};

[stage(vertex)]
fn vs_main(
    input: VsInput,
) VsOutput {
    let my_image: @Image2D(float) = image;
    let a: float3;
    let b: float = a.xyz.z;
    let c: int = test(1);
    c = test2(1);
    let d: float3 = float3(0.1123);
    let e: float3x3 = float3x3(
        float3(0.1123),
        float3(0.1123),
        float3(0.1123),
    );
    let f: float3x3 = float3x3(d);

    let str: Hello = Hello.{
        a: 123,
        b: d.x,
    };

    str = Hello.{ a: 123, b: 321 };

    str.a = 123;

    {
        let member: float = str.b;
    }

    // out_uv = in_uv;
    // out_position = float4(in_pos, 1);
    return VsOutput.{
        pos: input.pos,
    };
}

[stage(fragment)]
fn fs_main([location(0)] in_pos: float3) [location(0)] float4 {
    // let color: float4 = @sample(sampler, image, uv);

    // out_color = float4(color, 1.0);

    // let a: float3 = in_pos;

    let i: int = 123;
    let u: uint = uint(i);
    i = 321;
    let f: float = float(i);

    let s: float2 = @sin(float2(123,123));
    s = @tan(s);
    s = @atanh(s);
    s = @sqrt(s);
    s = @inverseSqrt(s);
    s = @log(s);
    s = @fract(s);
    s = @ceil(s);
    s = @floor(s);
    s = @trunc(s);
    s = @exp2(s) + s * (123 + 123);

    let my_arr_arr: [2][2]float;
    let my_arr: [2]float = my_arr_arr[0];
    my_arr_arr[0][0] = 123;

    let my_mat: float4x4;
    let my_vec: float4;
    my_mat = my_mat * my_mat;
    my_vec = my_mat * -my_vec;

    my_vec += float4(1);

    let other: float3 = float3(1).xxx;
    other.x = 123;
    return float4(float3(1, 2, 3), 1);
}

[stage(fragment)]
fn fs_main2([location(0)] in_pos: float3) [location(0)] float4 {
    let some_var: int = 123;
    if (int(1) == int(0)) {

    }

    while (some_var == int(0)) {
    }

    let some_bool : bool = true || false;
    if (some_bool) {
        let asdasdasd: uint = @abs(uint(123));
    }

    let dist: float = @distance(float3(1, 2, 3), float3(3, 2, 1));
    let norm: float3 = @normalize(float3(1, 2, 3));
    let dot: float = @dot(norm, float3(3, 2, 1));
    let len: float = @length(norm);
    let cross: float3 = @cross(norm, norm);
    let reflect: float3 = @reflect(norm, norm);
    let refract: float3 = @refract(norm, norm, 0.5);
    let min: float = @min(0.5, 0.3);
    let max: float3 = @max(norm, norm);
    let mix: float3 = @mix(norm, norm, float3(0.2));
    let clamp: float3 = @clamp(norm, float3(0.1), float3(0.2));
    let len2: uint = uniform.some_arr.len;

    return float4(float3(1, 2, 3), 1);
}
